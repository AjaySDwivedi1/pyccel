Pyccel:
  (statements*=Statement)
;

Statement:
  (SimpleStmt | CompoundStmt)
;

SimpleStmt:
  SmallStmt (';' SmallStmt)* (';')?
;

SmallStmt:
  (HiddenStmt | PassStmt | FlowStmt | DelStmt | ImportStmt | DeclarationStmt | ExprStmt | PythonStdLibStmt)
;

CompoundStmt:
  (IfStmt | ForStmt | DecoratedStmt)
;

SuiteStmt: 
  SimpleStmt 
//  | 
//  INDENT stmt+ DEDENT
//  NEWLINE INDENT stmt+ DEDENT
;

//DecoratorStmt: 
//  '@' dotted_name ( '(' (arglist)? ')' )? NEWLINE
//;
//
//DecoratorsStmt: 
//  decorator+
//;

DecoratedStmt: 
//  decorators (classdef | funcdef | async_funcdef)
  FunctionDefStmt
;

FunctionDefStmt: 
  'def' name=ID LPAREN args*=ID[','] RPAREN ':'
  INDENT
  (body+=SmallStmt[';'])? (body+=CompoundStmt)? 
  DEDENT
;

PassStmt:
  label='pass'
;

FlowStmt:
  (BreakStmt | ContinueStmt | ReturnStmt | RaiseStmt | YieldStmt)
;

BreakStmt:
  label='break'
;

ContinueStmt:
  label='continue'
;

ReturnStmt:
  label='return' (variables*=ID[','])
;

RaiseStmt:
  label='raise'
;

YieldStmt:
  label='yield'
;

DelStmt:
  'del' variables*=ID[',']
;

HiddenStmt:
  (AnnotatedStmt | CommentStmt)
//  (CommentStmt | AnnotatedStmt)
;

CommentStmt:
//  '#' text=/[^x].*$/  
  '#' text=/.*$/
;

AnnotatedStmt:
  '#@' accel=Accelerator 
  (do='do')? 
  (end='end')? 
  (parallel='parallel')? 
  (section='for')? 
  (visibility='private'|'shared')? 
  (LPAREN variables+=ID[','] RPAREN)?
;

Accelerator:
  ('omp' | 'acc')
;


ImportStmt: 
  ImportNameStmt | ImportFromStmt 
;

ImportNameStmt: 
  'import' DottedAsNames
;

// note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSIS
ImportFromStmt: ('from' (('.' | '...')* dotted_name=DottedName | ('.' | '...')+)
              'import' ('*' | '(' import_as_names=ImportAsNames ')' | import_as_names=ImportAsNames));

ImportAsName: 
  ID ('as' ID)?
;

DottedAsName: 
  DottedName ('as' ID)?
;

ImportAsNames: 
//  ImportAsName (',' ImportAsName)* (',')?
  names+=ImportAsName[','] 
;

DottedAsNames: 
  DottedAsName (',' DottedAsName)*
;

DottedName: 
  names+=ID['.'] 
;

//global_stmt: 'global' ID (',' ID)*;
//nonlocal_stmt: 'nonlocal' ID (',' ID)*;
//assert_stmt: 'assert' test (',' test)?;

DeclarationStmt: 
  datatype=DataType variables+=ID[',']
;

DataType:
  ('double' | 'float' | 'int')
;

ParameterTest:
  ('shape' | 'dtype')
;

Variable:
  ID
;

IdentifierOrNumber:
  (NUMBER | ID)
;

ArgList:
  LPAREN args+=IdentifierOrNumber[','] RPAREN
;

PythonStdLibStmt:
  (PythonPrintStmt)
;

ExprStmt: 
  (NumpyStmt | AssignStmt)
;

PythonPrintStmt: 
  name='print' LPAREN args+=Expression[','] RPAREN 
;

NumpyStmt: 
  (NumpyZerosStmt | NumpyZerosLikeStmt | NumpyOnesStmt | NumpyLinspaceStmt)
;

ParameterValue:
  (value=IdentifierOrNumber | value=ArgList)
;

ParameterSingle: 
  label=ParameterTest '=' value=ParameterValue
;

NumpyZerosStmt: 
  lhs=ID '=' ZEROS LPAREN parameters+=ParameterSingle[','] RPAREN 
;

NumpyZerosLikeStmt: 
  lhs=ID '=' ZEROSLIKE LPAREN rhs=ID RPAREN 
;

NumpyOnesStmt: 
  lhs=ID '=' ONES LPAREN shape=INT RPAREN 
;

NumpyLinspaceStmt: 
  lhs=ID '=' LINSPACE LPAREN 
                             start=IdentifierOrNumber COMMA
                             end=IdentifierOrNumber COMMA
                             size=INT
                       RPAREN 
;

AssignStmt: 
  lhs=ID (trailer=Trailer)? '=' rhs=Expression
;

ForStmt: 
  'for' iterable=ID 'in' 
  'range' LPAREN start=IdentifierOrNumber COMMA 
                 end=IdentifierOrNumber RPAREN ':' 
  INDENT
  (body+=SmallStmt[';'])? (body+=CompoundStmt)? 
  DEDENT
;

IfStmt: 
  'if' test=Test ':'
  INDENT
  (body_true+=SmallStmt[';'])? (body_true+=CompoundStmt)? 
  DEDENT
//  ('elif' test=Test ':' SuiteStmt)* 
  ('else' ':'
  INDENT
  (body_false+=SmallStmt[';'])? (body_false+=CompoundStmt)? 
  DEDENT)? 
;

Test: 
  op=OrTest ('if' OrTest 'else' Test)? 
;

OrTest: 
  op=AndTest ('or' op=AndTest)*
;

AndTest: 
//  op=NotTest ('and' op=NotTest)*
  op=Comparison ('and' op=Comparison)*
;

//NotTest: 
//  (op='not')? op=Comparison
//;

Comparison: 
  op=Expression (op=CompOp op=Expression)* 
;

// <> isn't actually a valid comparison operator in Python. It's here for the
// sake of a __future__ import described in PEP 401 (which really works :-)
CompOp: 
  '>='|'<='|'<>'|'<'|'>'|'=='|'!='|'in'|'not' 'in'|'is'|'is' 'not'
;

Expression: 
  op=Term (op=PlusOrMinus op=Term)* 
;

Term: 
  op=Factor (op=MulOrDiv op=Factor)*
;

Factor: 
  FactorBinary | FactorUnary | FactorSigned
;

// TODO trailer must be a list 
FactorSigned: 
  (sign=PlusOrMinus)?  op=Operand (trailer=Trailer)?
;

FactorUnary:
  name=UnaryOp LPAREN op=Operand (trailer=Trailer)? RPAREN
;

FactorBinary:
  name=BinaryOp LPAREN op=Factor COMMA op=Factor RPAREN
;

Trailer: 
  (args=TrailerArgList)?
  | (subs=TrailerSubscriptList)?
;

TrailerArgList: 
  '[' args+=Expression[','] ']'
;

TrailerSubscriptList: 
  '[' args+=Expression[':'] ']'
;

Operand: 
  (op=NUMBER) | (op=ID) | (op=BOOLEAN) //| (LPAREN op=Expression RPAREN)
;

BOOLEAN:
   ('True'|'False')
;

UnaryOp:
   ('transpose')
;

BinaryOp:
   ('pow')
;

EQ:
  "="
;

DEF:
  "::" | ":="
;

IN:
  "::"
;

COMMA:
  ","
;

SUBSCRIPT:
  '_'
;

LPAREN:
  "("
;

RPAREN:
  ")"
;

PlusOrMinus: 
  '+' | '-'
;

MulOrDiv: 
  '*' | '/' 
;

//Comment:
//  /#.*$/
//;

INDENT:
  'indent'
;

DEDENT:
  'dedent'
;

ZEROS:
  'zeros'
;

ZEROSLIKE:
  'zeroslike'
;

ONES:
  'ones'
;

LINSPACE:
  'linspace'
;

AWAIT:
  'await'
;
