import openmp.grammar

Pyccel:
  (statements*=Statement)
;

Statement:
    SimpleStmt 
  | CompoundStmt
;

SimpleStmt:
  SmallStmt (';' SmallStmt)* (';')?
;

SmallStmt:
    AnnotatedStmt 
  | CommentStmt 
  | PassStmt 
  | FlowStmt 
  | DelStmt 
  | ImportStmt 
  | ConstructorStmt 
  | DeclarationStmt 
  | ExprStmt 
  | PythonStdLibStmt
;

FlowStmt:
    BreakStmt 
  | ContinueStmt 
  | ReturnStmt 
  | RaiseStmt 
  | YieldStmt
;

CompoundStmt:
    IfStmt 
  | ForStmt 
  | DecoratedStmt
  | WhileStmt
;

AnnotatedStmt:
    HeaderStmt 
  | OpenmpStmt
;

ExprStmt: 
    StencilStmt 
  | ThreadStmt 
  | EvalStmt 
  | AssignStmt 
  | MultiAssignStmt
;

SuiteStmt: 
//  SimpleStmt 
//  | 
  INDENT
  stmts+=Statement
  DEDENT
;

//DecoratorStmt: 
//  '@' dotted_name ( '(' (arglist)? ')' )? NEWLINE
//;
//
//DecoratorsStmt: 
//  decorator+
//;

DecoratedStmt: 
//  decorators (classdef | funcdef | async_funcdef)
  FunctionDefStmt
;

FunctionDefStmt: 
  'def' name=ID '(' args*=ID[','] ')' ':'
  body=SuiteStmt
;
FunctionCall:
   ID '(' args*=ID[','] ')'
;

PassStmt:
  label='pass'
;

BreakStmt:
  label='break'
;

ContinueStmt:
  label='continue'
;

ReturnStmt:
  label='return' (variables*=ID[','])
;

RaiseStmt:
  label='raise'
;

YieldStmt:
  label='yield'
;

DelStmt:
  'del' variables*=ID[',']
;

CommentStmt:
//  '#' text=/[^x].*$/  
  '#' text=/.*$/
;

HeaderStmt: 
  '#$' 'header' name=ID '(' decs*=DeclareAtom[','] ')'
;

DeclareAtom:
  dtype=ID (trailer=TrailerSubscriptList)?
;

ImportStmt: 
  ImportNameStmt | ImportFromStmt 
;

ImportNameStmt: 
  'import' DottedAsNames
;

// note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSIS
ImportFromStmt: 
  ('from'  (('.' | '...')* dotted_name=DottedName | ('.' | '...')+) 
   'import' ('*' | '(' import_as_names=ImportAsNames ')' | import_as_names=ImportAsNames))
;

ImportAsName: 
  ID ('as' ID)?
;

DottedAsName: 
  DottedName ('as' ID)?
;

ImportAsNames: 
//  ImportAsName (',' ImportAsName)* (',')?
  names+=ImportAsName[','] 
;

DottedAsNames: 
  DottedAsName (',' DottedAsName)*
;

DottedName: 
  names+=ID['.'] 
;

//global_stmt: 'global' ID (',' ID)*;
//nonlocal_stmt: 'nonlocal' ID (',' ID)*;
//assert_stmt: 'assert' test (',' test)?;

DeclarationStmt: 
  datatype=DataType variables+=ID[',']
;

DataType:
    'double' 
  | 'float' 
  | 'int' 
  | 'complex'
;

ParameterTest:
  ID | STRING
;

Variable:
  ID
;

ConstructorStmt:
  lhs=ID '=' constructor=Constructor '(' ')' 
;

Constructor:
  DataType 
;

IdentifierOrNumber:
    Float 
  | INT 
  | ID
;

ArgList:
  '(' args+=Args[','] ')'
;

Args:
    ArgList 
  | IdentifierOrNumber
;

PythonStdLibStmt:
  (PythonPrintStmt)
;

PythonPrintStmt: 
  name='print' '('   (args+=PrintStmt[',']) ')' 
;
PrintStmt:
  (STRING|Expression)
;

ParameterValue:
  (value=IdentifierOrNumber |value=ArgList)
;

ParameterSingle: 
  label=ParameterTest '=' value=ParameterValue
;

ThreadStmt: 
  lhs=ID '=' func=ThreadFunction '(' ')' 
;

ThreadFunction:
    'thread_id' 
  | 'thread_number'
;

StencilStmt: 
  lhs=ID '=' 'stencil' '(' parameters+=ParameterSingle[','] ')' 
;

AssignStmt: 
  lhs=ID (trailer=Trailer)? '=' rhs=Expression 
;

MultiAssignStmt: 
  lhs+=ID[','] '=' rhs=Expression
;

EvalStmt: 
  lhs+=ID[','] '=' 'eval' '(' module=STRING ',' function=STRING ',' args=ArgList ')'
;

ForStmt: 
  'for' iterable=ID 'in' 
  'range' '(' start=Expression ',' 
                 end=Expression 
                (',' step=Expression)? ')' ':' 
  body=SuiteStmt
;

WhileStmt:
  'while' test=OrTest ':'
  body=SuiteStmt
;

IfStmt: 
  'if' test=Test ':' body_true=SuiteStmt
  (body_elif*=ElifStmt)? 
  ('else' ':' body_false=SuiteStmt)? 
;

ElifStmt:
  ('elif' test=Test ':' body=SuiteStmt) 
;

Test: 
  op=OrTest ('if' OrTest 'else' Test)? 
;

OrTest: 
  op=AndTest ('or' op=AndTest)*
;

AndTest: 
//  op=NotTest ('and' op=NotTest)*
  op=Comparison ('and' op=Comparison)*
;

//NotTest: 
//  (op='not')? op=Comparison
//;

Comparison: 
  op=Expression (op=CompOp op=Expression)* 
;

// <> isn't actually a valid comparison operator in Python. It's here for the
// sake of a __future__ import described in PEP 401 (which really works :-)
CompOp: 
    '>='
  | '<='
  | '<>'
  | '<'
  | '>'
  | '=='
  | '!='
  | 'in'
  | 'not' 'in'
  | 'is'
  | 'is' 'not'
;

Expression: 
  op=Term (op=PlusOrMinus op=Term)* 
;

Term: 
  op=Factor (op=MulOrDiv op=Factor)*
;

Factor: 
  FactorSigned
;

// TODO trailer must be a list 
FactorSigned: 
  (sign=PlusOrMinus)?  op=Operand (trailer=Trailer)?
;

Trailer: 
  (args=TrailerArgList)?
  | (subs=TrailerSubscriptList)?
;

TrailerArgList: 
  '(' args+=TrailerArg[','] ')'
;

TrailerArg: 
    TrailerArgList 
  | Expression
;

TrailerSubscriptList: 
  '[' args+=TrailerSubscript[','] ']'
;

TrailerSubscript: 
    TrailerSlice 
  | TrailerSliceLeft 
  | TrailerSliceRight 
  | TrailerSliceEmpty 
  | Expression
;

TrailerSliceLeft:
  (start=Expression ':')
;

TrailerSliceRight:
  (':' end=Expression)
;

TrailerSlice:
  (start=Expression ':' end=Expression)
;

TrailerSliceEmpty:
  (dots=':')
;

Operand: 
    (op=Float) 
  | (op=INT) 
  | (op=ID) 
  | (op=BOOLEAN) 
;

Float:
  /[-+]?[0-9]*\.[0-9]+([eE][-+]?[0-9]+)?\b/
;

BOOLEAN:
    'True'
  | 'False'
;

//UnaryOp:
//   ('transpose')

PlusOrMinus: 
  '+' | '-'
;

MulOrDiv: 
  '*' | '/' 
;

//Comment:
//  /#.*$/
//;

INDENT:
  'indent'
;

DEDENT:
  'dedent'
;
