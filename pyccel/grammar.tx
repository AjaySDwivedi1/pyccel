Pyccel:
  (statements*=Statement)
;

Statement:
  (SimpleStmt | CompoundStmt)
;

SimpleStmt:
  SmallStmt (';' SmallStmt)* (';')?
;

SmallStmt:
  (PassStmt | FlowStmt | DelStmt | DeclarationStmt | ExprStmt )
;

CompoundStmt:
  (IfStmt | ForStmt | DecoratedStmt)
;

SuiteStmt: 
  SimpleStmt 
//  | 
//  INDENT stmt+ DEDENT
//  NEWLINE INDENT stmt+ DEDENT
;

//DecoratorStmt: 
//  '@' dotted_name ( '(' (arglist)? ')' )? NEWLINE
//;
//
//DecoratorsStmt: 
//  decorator+
//;

DecoratedStmt: 
//  decorators (classdef | funcdef | async_funcdef)
  FunctionDefStmt
;

FunctionDefStmt: 
  'def' name=ID LPAREN args*=ID[','] RPAREN ':'
  INDENT
  body+=Statement[';']
  DEDENT
;

PassStmt:
  label='pass'
;

FlowStmt:
  (BreakStmt | ContinueStmt | ReturnStmt | RaiseStmt | YieldStmt)
;

BreakStmt:
  label='break'
;

ContinueStmt:
  label='continue'
;

ReturnStmt:
  label='return' (variables*=ID[','])
;

RaiseStmt:
  label='raise'
;

YieldStmt:
  label='yield'
;

DelStmt:
  'del' variables*=ID[',']
;


DeclarationStmt: 
  datatype=DataType variables+=ID[',']
;

DataType:
  ('double' | 'int')
;

Variable:
  ID
;

IdentifierOrNumber:
  (NUMBER | ID)
;

ExprStmt: 
  (NumpyStmt | AssignStmt)
;

NumpyStmt: 
  (NumpyZerosStmt | NumpyZerosLikeStmt | NumpyOnesStmt | NumpyLinspaceStmt)
;

NumpyZerosStmt: 
  lhs+=ID[','] '=' ZEROS LPAREN shape=INT RPAREN 
;

NumpyZerosLikeStmt: 
  lhs+=ID[','] '=' ZEROSLIKE LPAREN rhs=ID RPAREN 
;

NumpyOnesStmt: 
  lhs+=ID[','] '=' ONES LPAREN shape=INT RPAREN 
;

NumpyLinspaceStmt: 
  lhs+=ID[','] '=' LINSPACE LPAREN 
                                  start=IdentifierOrNumber COMMA
                                  end=IdentifierOrNumber COMMA
                                  size=INT
                            RPAREN 
;

AssignStmt: 
  lhs+=ID[','] '=' rhs=Expression
;

ForStmt: 
  'for' iterable=ID 'in' 
  'range' LPAREN start=IdentifierOrNumber COMMA 
                 end=IdentifierOrNumber RPAREN ':' 
//  body+=SmallStmt[';']
  INDENT
  body+=Statement[';']
  DEDENT
;

IfStmt: 
  'if' test=Test ':'
  INDENT
  body_true+=Statement[';']
  DEDENT
//  ('elif' test=Test ':' SuiteStmt)* 
  ('else' ':'
  INDENT
  body_false+=Statement[';']
  DEDENT)? 
;

Test: 
  OrTest ('if' OrTest 'else' Test)? 
//  | lambdef
;

//test_nocond: or_test | lambdef_nocond;
//lambdef: 'lambda' (varargslist)? ':' test;
//lambdef_nocond: 'lambda' (varargslist)? ':' test_nocond;

OrTest: 
  AndTest ('or' AndTest)*
;

AndTest: 
  NotTest ('and' NotTest)*
;

NotTest: 
  'not' NotTest 
  | Comparison
;

Comparison: 
  Expression (CompOp Expression)*
;

// <> isn't actually a valid comparison operator in Python. It's here for the
// sake of a __future__ import described in PEP 401 (which really works :-)
CompOp: 
  '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'
;

Expression: 
  op=Term (op=PlusOrMinus op=Term)* 
;

Term: 
  op=Factor (op=MulOrDiv op=Factor)*
;

Factor: 
  FactorBinary | FactorUnary | FactorSigned
;

FactorSigned: 
  (sign=PlusOrMinus)?  op=Operand
;

FactorUnary:
  name=UnaryOp LPAREN op=Operand RPAREN
;

FactorBinary:
  name=BinaryOp LPAREN op=Factor COMMA op=Factor RPAREN
;

// there is a problem with this rule, only on my laptop
// it seems it can't parse a word like phi, and only returns "p"
Operand: 
  (op=NUMBER) | (op=ID) | (LPAREN op=Expression RPAREN)
;

UnaryOp:
   ('grad'|'curl'|'div'|'dxx'|'dyy'|'dzz'|'dxy'|'dyz'|'dxz'|'dx'|'dy'|'dz')
;

BinaryOp:
   ('dot'|'inner'|'outer'|'cross')
;

EQ:
  "="
;

DEF:
  "::" | ":="
;

IN:
  "::"
;

COMMA:
  ","
;

SUBSCRIPT:
  '_'
;

LPAREN:
  "("
;

RPAREN:
  ")"
;

LTRIANGLE: 
  '<'
;

RTRIANGLE:
  '>'
;

PlusOrMinus: 
  '+' | '-'
;

MulOrDiv: 
  '*' | '/' 
;

Comment:
  /#.*$/
;

INDENT:
  'indent'
;

DEDENT:
  'dedent'
;

ZEROS:
  'zeros'
;

ZEROSLIKE:
  'zeroslike'
;

ONES:
  'ones'
;

LINSPACE:
  'linspace'
;
