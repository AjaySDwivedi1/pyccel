// TODO: - decorators
//       - continuation line
//       - augassign 
//       - dotted names 
//       - boolean expr in factor
//       - class 
//       - io files  
//       - command line args 
//       - OpFactor: add '//'
//       - OpFactorSigned: add '~'
//       - Atom: add dictorsetmaker 
//       - Atom: add  '...'
//       - Atom: add STRING+ 
//       - Atom: add yield expr 
//       - AtomExpr: allow multiple trailers 
//       -  
//       -  
//       -  

import openmp.grammar

Pyccel:
  (statements*=Statement)
;

Statement:
    SimpleStmt 
  | CompoundStmt
;

SimpleStmt:
  SmallStmt (';' SmallStmt)* (';')?
;

SmallStmt:
    AnnotatedStmt 
  | CommentStmt 
  | PassStmt 
  | FlowStmt 
  | DelStmt 
  | ImportStmt 
  | ConstructorStmt 
  | DeclarationStmt 
  | ExprStmt 
  | PythonStdLibStmt
;

FlowStmt:
    BreakStmt 
  | ContinueStmt 
  | ReturnStmt 
  | RaiseStmt 
  | YieldStmt
;

CompoundStmt:
    IfStmt 
  | ForStmt 
  | DecoratedStmt
  | WhileStmt
;

AnnotatedStmt:
    HeaderStmt 
  | OpenmpStmt
;

ExprStmt: 
    StencilStmt 
  | ThreadStmt 
  | EvalStmt 
  | AssignStmt 
  | MultiAssignStmt
;

SuiteStmt: 
//  SimpleStmt 
//  | 
  INDENT
  stmts+=Statement
  DEDENT
;

//DecoratorStmt: 
//  '@' dotted_name ( '(' (arglist)? ')' )? NEWLINE
//;
//
//DecoratorsStmt: 
//  decorator+
//;

DecoratedStmt: 
//  decorators (classdef | funcdef | async_funcdef)
  FunctionDefStmt
;

FunctionDefStmt: 
  DEF name=ID '(' args*=ID[','] ')' ':'
  body=SuiteStmt
;

PassStmt: label=PASS;
BreakStmt: label=BREAK;
ContinueStmt: label=CONTINUE;
RaiseStmt: label=RAISE;
YieldStmt: label=YIELD;

ReturnStmt:
  label=RETURN (variables*=ID[','])
;

DelStmt:
  DEL variables*=ID[',']
;

CommentStmt:
//  '#' text=/[^x].*$/  
  '#' text=/.*$/
;

HeaderStmt: '#$' 'header' name=ID '(' decs*=DeclareAtom[','] ')';
DeclareAtom: dtype=ID (trailer=TrailerSubscriptList)?;

ImportStmt: ImportNameStmt | ImportFromStmt ;
ImportNameStmt: IMPORT DottedAsNames;

// note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSIS
ImportFromStmt: 
  (FROM  (('.' | '...')* dotted_name=DottedName | ('.' | '...')+) 
   IMPORT ('*' | '(' import_as_names=ImportAsNames ')' | import_as_names=ImportAsNames))
;

ImportAsName: ID (AS ID)?;
DottedAsName: DottedName (AS ID)?;

ImportAsNames: 
//  ImportAsName (',' ImportAsName)* (',')?
  names+=ImportAsName[','] 
;

DottedAsNames: DottedAsName (',' DottedAsName)*;
DottedName: names+=ID['.'];

//global_stmt: 'global' ID (',' ID)*;
//nonlocal_stmt: 'nonlocal' ID (',' ID)*;
//assert_stmt: 'assert' test (',' test)?;

DeclarationStmt: datatype=DataType variables+=ID[','];

DataType:
    'double' 
  | 'float' 
  | 'int' 
  | 'complex'
;

ParameterTest: ID | STRING;
Variable: ID;

ConstructorStmt: lhs=ID '=' constructor=Constructor '(' ')' ;
Constructor: DataType ;

IdentifierOrNumber: Number | ID;

ArgList: '(' args+=Args[','] ')';
Args: ArgList | IdentifierOrNumber;

// TODO: remove
PythonStdLibStmt: PythonPrintStmt;

PythonPrintStmt: name='print' '('   (args+=PrintStmt[',']) ')';
PrintStmt: STRING | Expression;

// TODO: remove
ParameterValue: (value=IdentifierOrNumber |value=ArgList);
ParameterSingle: label=ParameterTest '=' value=ParameterValue;

AssignStmt: lhs=ID (trailer=Trailer)? '=' rhs=Expression;
MultiAssignStmt: lhs+=ID[','] '=' rhs=Expression;

StencilStmt: lhs=ID '=' 'stencil' '(' parameters+=ParameterSingle[','] ')' ;
EvalStmt: 
  lhs+=ID[','] '=' 'eval' '(' module=STRING ',' function=STRING ',' args=ArgList ')'
;

// TODO: improve
ThreadStmt: lhs=ID '=' func=ThreadFunction '(' ')';
ThreadFunction: 'thread_id' | 'thread_number';

ForStmt: 
  'for' iterable=ID 'in' 
  'range' '(' start=Expression ',' 
                 end=Expression 
                (',' step=Expression)? ')' ':' 
  body=SuiteStmt
;

WhileStmt:
  WHILE test=OrTest ':'
  body=SuiteStmt
;

IfStmt: 
  IF test=Test ':' body_true=SuiteStmt
  (body_elif*=ElifStmt)? 
  (ELSE ':' body_false=SuiteStmt)? 
;

ElifStmt:
  (ELIF test=Test ':' body=SuiteStmt) 
;

Test: op=OrTest (IF OrTest ELSE Test)?;
OrTest: op=AndTest (OR op=AndTest)*;
AndTest: op=Comparison (AND op=Comparison)*;
Comparison: op=Expression (op=OpComp op=Expression)*;

Expression: ArithmeticExpression;
ArithmeticExpression: op=Term (op=OpPlusOrMinus op=Term)*;
Term: op=Factor (op=OpFactor op=Factor)*;
Factor: Power | FactorSigned;
FactorSigned: (sign=OpFactorSigned)?  op=AtomExpr;
Power: op=AtomExpr '**' exponent=Factor;
AtomExpr: op=Atom (trailer=Trailer)?;

Number: Float | INT;
Atom: 
    (op=Number) 
  | (op=ID) 
  | (op=NONE)
  | (op=TRUE)
  | (op=FALSE)
;
//Atom: 
//    '(' Factor ')'
//  | ID
//  | Number 
//  | NONE
//  | TRUE
//  | FALSE
//;

OpPlusOrMinus: '+' | '-';
OpFactor: '*' | '@' | '/' | '%' ;
OpFactorSigned: '+' | '-';
// <> isn't actually a valid comparison operator in Python. It's here for the
// sake of a __future__ import described in PEP 401 (which really works :-)
OpComp: 
    '>='
  | '<='
  | '<>'
  | '<'
  | '>'
  | '=='
  | '!='
  | 'in'
  | 'not' 'in'
  | 'is'
  | 'is' 'not'
;

// TODO: only use args
Trailer: 
    (args=TrailerArgList)?
  | (subs=TrailerSubscriptList)?
;

TrailerArgList: '(' args+=TrailerArg[','] ')';
TrailerArg: TrailerArgList | Expression;
TrailerSubscriptList: '[' args+=TrailerSubscript[','] ']';

TrailerSubscript: 
    TrailerSlice 
  | TrailerSliceLeft 
  | TrailerSliceRight 
  | TrailerSliceEmpty 
  | Expression
;

TrailerSliceLeft: (start=Expression ':');
TrailerSliceRight: (':' end=Expression);
TrailerSlice: (start=Expression ':' end=Expression);
TrailerSliceEmpty: (dots=':');

Operand: 
    (op=Float) 
  | (op=INT) 
  | (op=ID) 
  | (op=BOOLEAN) 
;

Float:
  /[-+]?[0-9]*\.[0-9]+([eE][-+]?[0-9]+)?\b/
;

BOOLEAN: TRUE | FALSE;

// indent/dedent are here since textX does not handle indentation yet
INDENT: 'indent';
DEDENT: 'dedent';

AND : 'and';
AS : 'as';
ASSERT : 'assert';
ASYNC : 'async';
AWAIT : 'await';
BREAK : 'break';
CLASS : 'class';
CONTINUE : 'continue';
DEL : 'del';
DEF : 'def';
ELIF : 'elif';
ELSE : 'else';
EXCEPT : 'except';
FALSE : 'False';
FINALLY : 'finally';
FOR : 'for';
FROM : 'from';
GLOBAL : 'global';
IF : 'if';
IN : 'in';
IS : 'is';
IMPORT : 'import';
LAMBDA : 'lambda';
NONE : 'None';
NONLOCAL : 'nonlocal';
NOT : 'not';
OR : 'or';
PASS : 'pass';
RETURN : 'return';
RAISE : 'raise';
TRUE : 'True';
TRY : 'try';
WHILE : 'while';
WITH : 'with';
YIELD : 'yield';
